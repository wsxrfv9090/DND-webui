# 项目技术要求与备忘文档

## 一、项目目标与核心思路

目标：实现一个基于DND规则的AI Agent游戏Demo，AI作为DM（Dungeon Master），玩家通过Web页面与AI互动，体验自动生成的冒险故事。
核心结构：三层世界观（世界观设定 → 地图网状结构 → 节点内容与数据），AI生成内容受限于结构，代码负责规则与状态判定。

## 二、技术要求

1. 架构设计
前端：Web UI，负责玩家输入、展示AI输出（建议用React/Vue/简单HTML+JS，优先选你最熟悉的）。
后端：负责
游戏规则判定（如投骰、伤害、状态管理等）
状态数据管理（玩家属性、物品、任务、NPC等）
构造Prompt并调用AI接口（如OpenAI、Gemini等）
返回AI生成的描述文本
数据结构：
world.json：世界观描述
map.json：节点与连线（地理结构）
locations/xxx.json：每个节点的详细内容（NPC、任务、描述等）
2. MVP范围（最小可行产品）
1个世界观设定
2-3个地图节点（如新手村、洞穴、道路）
每节点1-2个NPC、1个主线任务、1-2个怪物
1个固定的随机事件
实现“探索-对话-战斗”核心循环
3. 代码分工建议
代码负责所有规则判定与状态管理（如投骰、HP、物品、任务进度等）
AI只负责描述、对话、氛围渲染，不做数值判定
前后端分离，后端API返回AI生成文本和最新状态
4. 技术选型建议
后端：Node.js (Express/Koa)、Python (Flask/FastAPI/Django)任选其一
前端：React/Vue/HTML+JS任选其一
AI接口：OpenAI GPT-3.5/4、Gemini、Azure OpenAI等
数据存储：本地JSON文件即可，便于快速开发和修改
三、实现备忘与注意事项
1. 重点与难点
规则判定与AI分工：务必让代码做“裁判”，AI做“演员”。所有数值、判定、状态变更都由代码完成，AI只描述结果。
Prompt构造：将判定结果、状态等以结构化方式（如JSON）传递给AI，要求AI只做描述，不要自作主张判定。
状态同步：每次玩家操作后，后端要更新所有相关状态，并确保传递给AI的内容是最新的。
MVP优先：只做最小可用Demo，避免贪多导致bug和进度拖延。
2. 可能遇到的坑
AI记忆力有限：不要指望AI能记住所有历史，状态要靠代码管理，AI只看你传给它的内容。
AI判定不准：不要让AI做任何数值相关的判定（如投骰、伤害），全部由代码完成。
API调用延迟：AI接口有延迟，尽量减少不必要的调用，合并多步描述为一次请求。
数据结构混乱：三层结构要清晰，便于后续扩展和维护。
7. 推荐开发流程
  先写好世界观、地图、节点的JSON数据
  实现后端的规则判定与状态管理（可先用伪数据测试）
  实现前端输入输出（可先用静态文本测试）
  接入AI接口，调试Prompt与输出
  联调，确保“探索-对话-战斗”流程跑通
  优化体验，准备演示

  ### 三、可选实现方法与工具

  投骰/判定：Math.random() 或 Python random
  状态管理：用对象/字典存储，定期写入JSON
  Prompt模板：用字符串模板拼接，或用Jinja2/EJS等模板引擎
  AI接口：用官方SDK或HTTP请求均可
  前端UI：可用简单聊天窗口+状态栏，优先保证交互流畅

  ## 四、三天冲刺建议

  Day 1：定好数据结构，写好世界观/地图/节点JSON，完成后端规则判定与状态管理
  Day 2：完成前端UI，联调后端API，接入AI接口
  Day 3：完善流程，优化体验，准备演示材料和答辩PPT

  ## 五、备忘清单

  [ ] 明确AI与代码分工
  [ ] 设计三层数据结构
  [ ] 先写好MVP用的世界观/地图/节点数据
  [ ] 后端实现所有规则与状态管理
  [ ] 前端实现输入输出与状态展示
  [ ] AI只做描述，不做判定
  [ ] 测试“探索-对话-战斗”完整流程
  [ ] 优化Prompt，减少API调用次数
  [ ] 准备演示用例和答辩材料







重要事件可能需要动态储存记录

两次ai：

需要根据用户的输入来反馈用户行为，是否要判定，判定什么、返回单一的tag（是否战斗、什么判定）